# 24点计算编程思路（Python Programming for Point 24 Game）

**Problem:**   
Get 24 from given 4 numbers (`1~13` like `A~K` of pokes)  
从四张扑克牌中的数字通过加减乘除运算，得到数字 24。

[**翔文数学**]() &copy; <kumath@outlook.com>



## 一、穷举法解决24点的计算问题

**对应程序：** [**doit.py**](src/do24.py)

目的：把四个数字的所有代数运算式进行尝试计算，要设法把所有**排列**计算一遍。  

(1) 四个整数位置的排列，用 $0,1,2,3$ 表示位置，排列是不能重复的，
所以有 $A_4^4$ 种情况，即 $4！=4\times 3\times 2\times 1=24$ 种；

~~~python
from itertools import permutations

def perms(narr):
    '''得到给定数组的全排列narray=[a,b,c,d]，4个数有4！个不同的排列
    建议用集合，可以预先删除重复项。
    '''
    return set(permutations(narr))
~~~

(2) 三个运算符的变化，每个运算符为 `+ - * /`, 可以相同，所以，
由乘法原理可得有 $4\times 4\times 4 = 4^3 = 64$ 种;   

~~~python
def operations(ndim):
    '''穷举各种运算排列，含重复运算，ndim = 给定数个数-1
    4个数，需要3个运算符号才能连起来。
    '''
    basic_ops = ['+','-','*','/']
    return product(basic_ops, repeat = ndim)
~~~

(3) 三个运算符的优先级，就是括号位置的变化，可能性为 $A_3^3-1=3!-1 = 6-1 = 5$ 种；  

要考虑运算顺序, 譬如：设四张牌为 $a、b、c、d$，代表4个数，运算符为 $①、②、③$，代表3个数学运算符号。
    代数表达式为 $a ① b ② c ③ d$。 
    这 3 个运算符的运算顺序有 $3！=6$ 种，分别是：  
    $1. \;①②③ \quad 2. \;①③② \quad 3. \;②①③$   
    $4. \;②③① \quad 5. \;③①② \quad 6. \;③②①$  
    等价的表达式分别是：  
    $1.\; [(a①b)②c]③d \quad 2. \; (a①b)②(c③d) \quad 3.\; [a①(b②c)]③d$  
    $4.\; a①[(b②c)③d] \quad 5. \; (a①b)②(c③d) \quad 6.\; a①[b②(c③d)]$  
    (2.)与(5.)等价, 只取其中之一。

~~~python
def get_expr(a, ops):
    #TODO: 清除 a+b=b+a, a*b=b*a的情形, 满足交换律只取一种，满足结合律也只取一种。
    if len(a) == 4:
        exp1 = '(({0}{1}{2}){3}{4}){5}{6}'.format(a[0], ops[0], a[1], ops[1], a[2], ops[2], a[3])
        exp2 = '({0}{1}{2}){3}({4}{5}{6})'.format(a[0], ops[0], a[1], ops[1], a[2], ops[2], a[3])
        exp3 = '({0}{1}({2}{3}{4})){5}{6}'.format(a[0], ops[0], a[1], ops[1], a[2], ops[2], a[3])
        exp4 = '{0}{1}(({2}{3}{4}){5}{6})'.format(a[0], ops[0], a[1], ops[1], a[2], ops[2], a[3])
        exp5 = '{0}{1}({2}{3}({4}{5}{6}))'.format(a[0], ops[0], a[1], ops[1], a[2], ops[2], a[3])
        expr = [exp1, exp2, exp3, exp4, exp5]
    if len(a) == 3:
        exp1 = '({0}{1}{2}){3}{4}'.format(a[0], ops[0], a[1], ops[1], a[2])
        exp2 = '{0}{1}({2}{3}{4})'.format(a[0], ops[0], a[1], ops[1], a[2])
        expr = [exp1, exp2]

    return expr
~~~

综上所述，所有可能的代数表达式为：$24\times 64\times 5=7680$ 种。

（4）对这组排列逐一进行运算，看是否是 $24$，就可以得到最终所有式子。  
在运算过程中除法的特殊性：除数不能为零。采用 `try...except` 跳过除数为零的情形。  
因为可能会用到除法，所以要考虑浮点数的精度问题，采用 `math` 库提供的内部函数 `isclose()` 达到比较目的。

~~~python
def find24(narr):
    '''找到所有结果是24的运算式,
    TODO: 如何清理重复的算式，可以交换的算式, 譬如 a*b = b*a, a+b = b+a
    '''

    ops = set(operations(len(narr)-1))  #
    perms_arr = perms(narr)  # 清除了带重复数的排列
    reslist = set()        # 集合对元素唯一性有要求

    for arr1 in perms_arr:
        for op in ops:
            expressions = get_expr(arr1, op)  # 组合数组和运算符号组
            #print(expr)
            for expr in expressions:
                try:
                    res = eval(expr)  # 计算表达式的值用eval(source)
                except ZeroDivisionError:
                    continue

                if isclose(res, RESULTN):
                    reslist.add('{0}={1}'.format(expr, int(res)))  # int(24.0)=24

    return reslist  # 集合可以清除相同项
~~~


## 二、寻求全部解的递归算法

**分治法**是一种循环迭代的算法，也可以看成一种递归思路。

Python 递归主程序 [**recurs24.py**](src/recurs24.py)

递归的思路逐步降维思路，在代码实现中，程序不断调用自身，每次调用都使大问题规模变小，最后达到退出条件（可以计算的条件）一层层返回直至解决原先的问题。

### 递归算法达到降维作用

采用**降低维度**的算法，即把**多维问题降低到二维甚至一维**来解决。

比如，给定四个数字 `[a, b, c, d]`，这是一个四维问题，我们首先要将其转换为二维问题。  

(1) 任取四个数中的两个，有$C(4, 2)=6$ 种取法，每种取法中得到包含两个数的全部表达式。  
假定首先取出`[a, b]`，考虑到加法和乘法的交换率，共有6种可能的表达式：   
即 `a+b, a-b, a*b, a/b, b-a, b/a`，则四维问题转化为了多组三维问题，    
即 `['a+b', c, d]，['a-b', c, d]，['a*b', c, d]， ['a/b', c, d]， ['b-a', c, d]， ['b/a', c, d]`。

~~~python
def merge2(a, b):
    '''两个数配一个运算符号，共有 6 种可能，去掉了 加法和乘法（满足交换律）中的重复项。a+b,a-b,a*b, b-a,a/b,b/a，注意排除掉除数为0的情形。'''
    res = set()
    ops = ['+','-','*','/']

    for i in range(3):
        res.add('{0} {1} {2}'.format(a, ops[i], b))
    
    res.add('{0} {1} {2}'.format(b, ops[1], a))
    
    if eval(str(b)) != 0:
        res.add('{0} {1} {2}'.format(a, ops[3], b))
    if eval(str(a)) !=0 :
        res.add('{0} {1} {2}'.format(b, ops[3], a))
    
    return res
~~~

所以将四维问题转化为三维问题共有 $C(4, 2) \times 6 = 36$ 种组合。  

(2) 重复上述过程，将三维问题继续转化为二维问题，同理，每一个三维问题都可转化为等价的二维问题，共有 $C(3, 2) \times 6 = 18$ 种组合。

(3) 四维问题转化为 $36 \times 18 = 648$ 种二维问题，每个二维问题又有 $6$ 种组合方式，所以，全部的表达式个数为 $648 \times 6 = 3888$ 个。

### 加括号算法

在每一次二维组合成新表达式的时候，我们根据原有的两个表达式的各自的运算符号和两个表达式之间的运算符号的关系来判断是否需要添加括号。

比如，$a、b$ 两个表达式要组成新的表达式，总共会有如下几种情况：  
（1）如果是 $a + b$，则完全不需要加括号；  
（2）如果是 $a * b$ 或者 $a / b$，若 $a、b$ 自身的运算符号是加号或减号，则应加括号，如 $a = a_1 + a_2，b$ 为数字，则 $a \times b = (a_1 + a_2) \times b$；  
（3）如果是 $a - b$，若 $b$ 为加号或减号，则 $b$ 应加括号，如 $b = b_1 - b_2，a = a_1 + a_2$，则 $a - b = a_1 + a_2 - (b_1 - b_2)$，但值得注意的是，$a_1 + a_2 - (b_1 - b_2)$ 其实等价于 $a_1 + a_2 - b_1 + b_2$，这种情况在其他的组合中其实已经存在。因此，可以无需再考虑括号问题；  
（4）如果是 $a / b$，若 $b$ 的符号是乘号或除号，原本也要加括号，但这种情况与上一种情况类似，我们出于计算简便考虑，可以不再考虑括号问题。

还有一种偷懒的方式，干脆全部加上括号。

### 去除等价表达式

对于一个表达式，$a + b - c + d$ 与如下表达式均是等价的：  
1) $a + d + b - c$
2) $b + a + d - c$
3) $b - c + a + d$

可以在任何一个表达式前再加一个加号，然后使用正则表达式对表达式进行切割成如下状态：`['+a', '+b', '-c', '+d']`。  
然后对其进行排序后再组合成字符串得到：$a + b + d - c$

这样的表达式称为**标准表达式**，凡是通过这样的处理方法得到的标准表达式是相同的，我们均认为是等价表达式，只保留一个标准表达式即可。

乘法交换率也是同样的转换方法。



